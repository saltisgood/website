<?php
/**
 * Created by BlogBuilder
 * Which was created by Nick Stephen
 * TITLE: Pretty C++ Templates
 * SUBTITLE: Separation of Interface and Implementation
 * DESC: The simple way to remove the implementation of your C++ Templates from their class definitions.
 * TAGS: C++;Templates;
 */
$sec = new Section();
$sec->heading = 'C++ Templates';
$para = new Paragraph();
$para->text = 'Templates are wonderful things. They allow us to create strongly typed but reusable collections, generate efficient function definitions and perform static type analysis, to name but a few uses.';
$sec->addParagraph($para);
$para = new Paragraph();
$para->text = 'They\'re also bloody annoying. Overly verbose, sometimes complicated and will spit out incredibly cryptic error messages if you mess something up.';
$sec->addParagraph($para);
$para = new Paragraph();
$para->text = 'That said, sometimes they\'re just the right tools for the job so you\'d better learn to use them.';
$sec->addParagraph($para);
$this->content[] = $sec;

$sec = new Section();
$sec->heading = 'Location Location Location';
$para = new Paragraph();
$para->text = 'One thing you\'ll learn pretty soon about templates in C++ is that they are almost always written entirely in header files. The reason for this is that whenever you use a template the compiler instantiates a new copy of the class/function and so it requires a definition of the methods or function. If the function is defined inside a different source file then the definition isn\'t available (unless of course you are #including that source file, in which case prepare for plenty more errors). Because of this, the typical solution is to simply declare and implement functions at the same time. That\'s certainly what Microsoft does:';
$sec->addParagraph($para);
$imgsec = new ImageSection();
$imgsec->type = ImageSection::BLOCK;
$img = new Image('/blog/img/AF1701-forward-list.png', 515, 619);
$img->setAltText('The VS implementation of std::forward_list');
$img->setCaption('The VS implementation of std::forward_list');
$imgsec->addImage($img);
$sec->addParagraph($imgsec);
$para = new Paragraph();
$para->text = 'Declaration and definition in one place and it\'s a mess to look at. Microsoft isn\'t particularly concerned about this because you don\'t normally read this code. This is their implementation of the standard library so you should only be using the facilities as documented by the C++ standard, which is so nicely represented by <a href="http://www.cplusplus.com/reference/">other people</a>.';
$sec->addParagraph($para);
$this->content[] = $sec;

$sec = new Section();
$sec->heading = 'There Must Be A Better Way';
$para = new Paragraph();
$para->text = 'And thankfully there is! The only requirement for templates to work is that they remain accessible to the compiler, not that they have to reside inside the class/function declaration. This gives a little flexibility, not much but a little. If you want the template to truly be general and be available for any template argument now and in the future without modification then the template must be fully defined before the end of the header file. However, if you only want or need the template to work for a few select arguments then you can defer the definitions to a source file.';
$sec->addParagraph($para);
$this->content[] = $sec;

$sec = new Section();
$sec->heading = 'Templates In a Source File';
$subsec = new SubSection('Usage Case:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Small/ Fixed number of template arguments');
$sec->addParagraph($list);
$subsec = new SubSection('Pros:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Can hide implementation in source file');
$list->addItem('No need to fully recompile program upon implementation change');
$sec->addParagraph($list);
$subsec = new SubSection('Cons:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Unsuitable for library code as every possible argument must be explicitly declared at the same time as the definitions');
$sec->addParagraph($list);
$subsec = new SubSection('Implementation:');
$sec->addParagraph($subsec);
$code = new CodeBlock('File: Example.h');
$code->addLine('<span class="code-b">namespace</span> ex ');
$code->addLine('{ ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">class</span> Foo ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{ ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">public</span>: ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo(<span class="code-b">const</span> Foo&lt;T&gt;&); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">int</span> doSomething(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U paramDo(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;}; ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T, <span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;U func(T param); ');
$code->addLine('} ');
$sec->addParagraph($code);
$code = new CodeBlock('File: Example.cpp');
$code->addLine('<span class="code-b">#include</span> <span class="code-r">"Example.h"</span> ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">using</span> <span class="code-b">namespace</span> ex; ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('Foo&lt;T&gt;::Foo()');
$code->addLine('{} ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('Foo&lt;T&gt;::Foo(<span class="code-b">const</span> Foo&lt;T&gt;& cpy)');
$code->addLine('{} ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('<span class="code-b">int</span> Foo&lt;T&gt;::doSomething()');
$code->addLine('{} ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> U&gt; ');
$code->addLine('U Foo&lt;T&gt;::paramDo&lt;U&gt;()');
$code->addLine('{} ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T, <span class="code-b">typename</span> U&gt; ');
$code->addLine('U ex::func&lt;T, U&gt;(T param)');
$code->addLine('{} ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-g">// Explicit Instantiations </span>');
$code->addLine('<span class="code-b">template</span> <span class="code-b">class</span> Foo&lt;<span class="code-b">int</span>&gt;; ');
$code->addLine('<span class="code-b">template</span> <span class="code-b">class</span> Foo&lt;<span class="code-b">float</span>&gt;; ');
$code->addLine('<span class="code-b">template</span> <span class="code-b">class</span> Foo&lt;Bar&gt;; ');
$code->addLine('&nbsp;');
$code->addLine('<span class="code-b">template</span> <span class="code-b">int</span> ex::func&lt;<span class="code-b">int</span>, <span class="code-b">float</span>&gt;(<span class="code-b">float</span>); ');
$code->addLine('<span class="code-b">template</span> Foo ex::func&lt;Foo, Bar&gt;(Bar); ');
$sec->addParagraph($code);
$subsec = new SubSection('Explanation:');
$subsec->addLine('Pretty straightforward really. The method definitions just have template <typename T> prepended and the parameter is then placed into the method signature. Other than that they\'re no different from normal method definitions.');
$subsec->addLine('The only strange one is method: paramDo(). paramDo() has the original template parameter of T which is for its surrounding class Foo, but it also has a second type parameter unique to it. For this reason there are 2 separate template declarations and the second parameter is placed at the end of the method name. You can\'t put both type parameters into a single template declaration unfortunately since they refer to 2 different instantiations. You can do it for the standalone template function as this uses both parameters at once.');
$subsec->addLine('Finally there are the template instantiations. These are identical and analogous to forward declarations, save for the prefix: template.');
$subsec->addLine('With this setup you can use any of these templates in any other part of the program as long as you include Example.h and the template arguments are one of those stated explicitly in Example.cpp. If you attempt to use one with an argument not explicitly stated then this will cause a linker error.');
$subsec->addLine('Note: The only reason for the namespace here is to make sure that the standalone function gets properly attached to the declaration in the header.');
$sec->addParagraph($subsec);
$this->content[] = $sec;

$sec = new Section();
$sec->heading = 'Templates in Headers';
$para = new Paragraph();
$para->text = 'This is my recommended solution.';
$sec->addParagraph($para);
$subsec = new SubSection('Usage Case:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Whenever you need a general template');
$sec->addParagraph($list);
$subsec = new SubSection('Pros:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Allows any template arguments');
$sec->addParagraph($list);
$subsec = new SubSection('Cons:');
$sec->addParagraph($subsec);
$list = new ListHTML();
$list->isOrdered = False;
$list->addItem('Implementation is fully exposed');
$sec->addParagraph($list);
$subsec = new SubSection('Implementation:');
$sec->addParagraph($subsec);
$code = new CodeBlock('File: Example.h');
$code->addLine('<span class="code-b">namespace</span> ex ');
$code->addLine('{ ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">class</span> Foo ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{ ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">public</span>: ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo(<span class="code-b">const</span> Foo&lt;T&gt;&); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">int</span> doSomething(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U paramDo(); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;}; ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T, <span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;U func(T param); ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('<span class="code-b">#pragma region</span> Implementations ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;Foo&lt;T&gt;::Foo()');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{} ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;Foo&lt;T&gt;::Foo(<span class="code-b">const</span> Foo&lt;T&gt;& cpy)');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{} ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">int</span> Foo&lt;T&gt;::doSomething()');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{} ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;U Foo&lt;T&gt;::paramDo&lt;U&gt;()');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{} ');
$code->addLine('&nbsp;');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-b">template</span> &lt;<span class="code-b">typename</span> T, <span class="code-b">typename</span> U&gt; ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;U func&lt;T, U&gt;(T param)');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;{} ');
$code->addLine('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');
$code->addLine('<span class="code-b">#pragma endregion</span> ');
$code->addLine('} ');
$sec->addParagraph($code);
$subsec = new SubSection('Explanation:');
$subsec->addLine('As you can see, the syntax is identical to the previous case, it\'s just appended to the end of the header. If you really don\'t want the implementations written in the same file then you can create another file, say Example.hpp, put the definitions in there and then #include that file from the bottom of Example.h. I prefer to skip that though and wrap the implementations in a #pragma region, which in Visual Studio folds away the code. Either way, the full definitions MUST be included somehow in any translation unit in which the header is included.');
$sec->addParagraph($subsec);
$this->content[] = $sec;

$sec = new Section();
$sec->heading = 'Wrap Up';
$para = new Paragraph();
$para->text = 'These are 2 very easy ways of having your own templates but not having to wade through code to figure out how to use them. Give it a go and check out how it cleans up your code. I guarantee you\'ll thank yourself later.';
$sec->addParagraph($para);
$this->content[] = $sec;

